// models/FcmToken.js
const mongoose = require("mongoose");
const Notification = require("../models/Notification");
// socket.js
const admin = require("firebase-admin");
const Message = require("../models/Message");
const HiddenUser = require("../models/HiddenUser");
const FcmToken = require("../models/FcmToken");
const { sendPushNotification } = require("../config/fcmUtils");
const User = require("../models/User");
let io;
const socketUsers = {};
let adminSocketId = null;
let activeUsers = {};
let messages = {};
let cachedHiddenUsers = new Set();
let user;
/**
 * L·∫•y FCM token c·ªßa user t·ª´ database
 */

const getFcmToken = async (userId) => {
  try {
    console.log("[getFcmToken] Nh·∫≠n userId:", userId);
    // ƒê·∫£m b·∫£o userId l√† chu·ªói h·ª£p l·ªá
    if (!mongoose.Types.ObjectId.isValid(userId)) {
      console.error("[getFcmToken] userId kh√¥ng h·ª£p l·ªá:", userId);
      return { success: false, error: "userId kh√¥ng h·ª£p l·ªá" };
    }

    const user = await User.findById(userId).select("fcmToken");
    console.log("[getFcmToken] K·∫øt qu·∫£ truy v·∫•n User:", user);

    if (!user) {
      console.error("[getFcmToken] Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng:", userId);
      return { success: false, error: "Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng" };
    }

    if (!user.fcmToken) {
      console.error("[getFcmToken] Kh√¥ng c√≥ FCM token cho userId:", userId);
      return { success: false, error: "Kh√¥ng t√¨m th·∫•y FCM token" };
    }

    console.log("[getFcmToken] FCM token:", user.fcmToken);
    return { success: true, token: user.fcmToken };
  } catch (error) {
    console.error("[getFcmToken] L·ªói:", error.message);
    return { success: false, error: error.message };
  }
};

module.exports = getFcmToken;

/**
 * L∆∞u ho·∫∑c c·∫≠p nh·∫≠t FCM token c·ªßa user v√†o database
 */
// Trong backend
const saveFcmToken = async (req, res) => {
  try {
    const { userId, token } = req.body;
    await FcmToken.findOneAndUpdate(
      { userId: new mongoose.Types.ObjectId(userId) },
      { token, updatedAt: new Date() },
      { upsert: true }
    );
    res.status(200).json({ message: "L∆∞u FCM token th√†nh c√¥ng" });
  } catch (error) {
    console.error(`[FCM] L·ªói khi l∆∞u token: ${error.message}`);
    res
      .status(500)
      .json({ message: "L·ªói khi l∆∞u FCM token", error: error.message });
  }
};

/**
 * G·ª≠i FCM notification ƒë·∫øn user c·ª• th·ªÉ
 */
const sendNotificationForUser = async (userIdentifier, notificationData) => {
  try {
    if (!notificationData.message) {
      console.error("[Notification] Thi·∫øu message trong notificationData");
      return { success: false, error: "Thi·∫øu message trong notificationData" };
    }

    let foundUser;
    if (mongoose.Types.ObjectId.isValid(userIdentifier)) {
      foundUser = await User.findById(userIdentifier);
    } else {
      foundUser = await User.findOne({
        $or: [{ username: userIdentifier }, { email: userIdentifier }],
      });
    }

    if (!foundUser) {
      console.error(
        `[Notification] Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng v·ªõi identifier: ${userIdentifier}`
      );
      return {
        success: false,
        error: `Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng v·ªõi identifier: ${userIdentifier}`,
      };
    }

    const username =
      foundUser.username || foundUser.email || "Ng∆∞·ªùi d√πng kh√¥ng x√°c ƒë·ªãnh";
    const fcmTokenResult = await getFcmToken(foundUser._id);

    // L∆∞u th√¥ng b√°o v√†o DB
    const notificationDoc = new Notification({
      userId: foundUser._id,
      username,
      title: notificationData.title || "Th√¥ng b√°o m·ªõi",
      message: notificationData.message,
      type: notificationData.type || "default",
      data: notificationData.data,
      read: false,
      timestamp: new Date(),
    });
    await notificationDoc.save();

    if (!fcmTokenResult.success) {
      console.error(
        `[Notification] ${fcmTokenResult.error} cho ${username} (${foundUser._id})`
      );
      return { success: false, error: fcmTokenResult.error };
    }

    // Chuy·ªÉn ƒë·ªïi t·∫•t c·∫£ gi√° tr·ªã trong data th√†nh chu·ªói
    const stringifiedData = {};
    for (const [key, value] of Object.entries(notificationData.data || {})) {
      stringifiedData[key] = String(value); // Chuy·ªÉn ƒë·ªïi th√†nh chu·ªói
    }

    const message = {
      token: fcmTokenResult.token,
      notification: {
        title: notificationData.title || "Th√¥ng b√°o m·ªõi",
        body: notificationData.message,
      },
      data: {
        type: notificationData.type || "default",
        ...stringifiedData, // S·ª≠ d·ª•ng d·ªØ li·ªáu ƒë√£ chuy·ªÉn ƒë·ªïi
      },
    };

    // G·ª≠i th√¥ng b√°o v√† ki·ªÉm tra k·∫øt qu·∫£
    try {
      await sendPushNotification(message);
      console.log(
        `[Notification] ƒê√£ g·ª≠i ƒë·∫øn ${username} (${foundUser._id}): ${notificationData.message}`
      );
      return { success: true, message: `ƒê√£ g·ª≠i th√¥ng b√°o ƒë·∫øn ${username}` };
    } catch (error) {
      console.error(`[FCM] L·ªói khi g·ª≠i th√¥ng b√°o: ${error.message}`);
      return {
        success: false,
        error: `L·ªói khi g·ª≠i th√¥ng b√°o FCM: ${error.message}`,
      };
    }
  } catch (error) {
    console.error(`[Notification] L·ªói khi g·ª≠i th√¥ng b√°o: ${error.message}`);
    return { success: false, error: error.message };
  }
};
/**
 * G·ª≠i broadcast FCM ƒë·∫øn t·∫•t c·∫£ users
 */
const sendNotificationToAllUsers = async (notification) => {
  const records = await FcmToken.find({}, "token");
  const tokens = records.map((r) => r.token);
  if (!tokens.length) {
    console.log("‚ùå Kh√¥ng c√≥ FCM token ƒë·ªÉ g·ª≠i broadcast.");
    return;
  }

  const message = {
    tokens,
    notification: {
      title: notification.title || "Th√¥ng b√°o t·ª´ h·ªá th·ªëng",
      body: notification.message || "B·∫°n c√≥ th√¥ng b√°o m·ªõi!",
    },
    data: Object.fromEntries(
      Object.entries(notification.data || {}).map(([k, v]) => [k, String(v)])
    ),
  };

  try {
    const response = await admin.messaging().sendMulticast(message);
    console.log("‚úÖ ƒê√£ g·ª≠i broadcast FCM notification:", response);
  } catch (error) {
    console.error("‚ùå L·ªói g·ª≠i broadcast FCM notification:", error);
  }
};

const initSocket = (server) => {
  io = require("socket.io")(server, { cors: { origin: "*" } });

  io.on("connection", (socket) => {
    // ƒêƒÉng k√Ω socket v√† l∆∞u FCM token
    socket.on("register", async ({ userId, username, fcmToken }) => {
      console.log(`üì• ƒê√£ nh·∫≠n register t·ª´ ${userId}, socketId: ${socket.id}`);
      if (userId === "admin") {
        socket.join("admin");
      }

      socketUsers[userId] = socket.id;
      activeUsers[userId] = username || userId;

      if (fcmToken) await saveFcmToken(userId, fcmToken);

      if (userId === "admin") {
        adminSocketId = socket.id;
        console.log("üü¢ Admin ƒë√£ k·∫øt n·ªëi:", adminSocketId);

        Message.distinct("sender", { receiver: "admin" })
          .then((pastUsers) => {
            pastUsers.forEach((user) => {
              if (!activeUsers[user]) activeUsers[user] = user;
            });
            updateAdminUserList();
          })
          .catch((err) => console.log("‚ùå L·ªói l·∫•y user c≈©:", err));
      } else {
        updateAdminUserList();
      }
    });

    // G·ª≠i tin nh·∫Øn ri√™ng
    socket.on("sendPrivateMessage", async (data, callback) => {
      const { sender, receiver, message: msgText } = data;

      if (!socketUsers[sender]) {
        return callback?.({
          status: "error",
          message: "B·∫°n ch∆∞a ƒëƒÉng k√Ω socket!",
        });
      }

      try {
        // L∆∞u tin nh·∫Øn v√†o DB
        const msg = new Message({
          sender,
          receiver,
          message: msgText,
          timestamp: new Date(),
        });
        await msg.save();
        const senderName = activeUsers[sender] || sender;

        // Emit real-time cho c·∫£ ng∆∞·ªùi g·ª≠i v√† ng∆∞·ªùi nh·∫≠n
        if (socketUsers[receiver]) {
          io.to(socketUsers[receiver]).emit("receivePrivateMessage", {
            sender,
            receiver,
            senderName,
            message: msgText,
            timestamp: msg.timestamp,
          });
        } else {
          // N·∫øu receiver offline, g·ª≠i FCM notification
          const notification = {
            title: "Tin nh·∫Øn t·ª´ Admin",
            message: "B·∫°n c√≥ tin nh·∫Øn m·ªõi t·ª´ Admin",
            data: {
              type: "message", // Th√™m type: 'message'
              sender,
              receiver,
              message: msgText,
            },
          };
          await sendNotificationForUser(receiver, notification);
        }

        // Emit l·∫°i cho ng∆∞·ªùi g·ª≠i
        if (socketUsers[sender]) {
          io.to(socketUsers[sender]).emit("receivePrivateMessage", {
            sender,
            senderName: activeUsers[sender] || sender,
            receiver,
            message: msgText,
            timestamp: msg.timestamp,
          });
        }

        // N·∫øu sender l√† admin, g·ª≠i th√¥ng b√°o popup cho user
        if (sender === "admin" && socketUsers[receiver]) {
          io.to(socketUsers[receiver]).emit("notification", {
            title: "Tin nh·∫Øn m·ªõi",
            message: msgText,
            type: "message", // Th√™m type ƒë·ªÉ ƒë·ªìng b·ªô
          });
        }

        // N·∫øu receiver l√† admin, l∆∞u th√¥ng b√°o v√†o DB v√† g·ª≠i socket
        if (receiver === "admin") {
          const notificationDoc = new Notification({
            userId: sender,
            username: activeUsers[sender] || sender,
            title: "B·∫°n c√≥ m·ªôt tin nh·∫Øn t·ª´ h·ªá th·ªëng",
            type: "message",
            message: msgText,
            timestamp: new Date(),
            read: false,
          });
          await notificationDoc.save();

          if (adminSocketId) {
            io.to(adminSocketId).emit("newNotification", {
              _id: notificationDoc._id,
              userId: sender,
              username: activeUsers[sender] || sender,
              type: "message",
              message: msgText,
              timestamp: notificationDoc.timestamp,
            });
          }

          // G·ª≠i FCM cho admin n·∫øu offline
          await sendNotificationForUser("admin", {
            title: "Tin nh·∫Øn t·ª´ ng∆∞·ªùi d√πng",
            message: `Tin nh·∫Øn m·ªõi t·ª´ ${senderName}: ${msgText}`,
            data: {
              type: "message", // Th√™m type: 'message'
              sender,
              receiver,
              message: msgText,
            },
          });
        }

        callback?.({ status: "ok" });
      } catch (err) {
        console.log("‚ùå L·ªói l∆∞u tin nh·∫Øn:", err);
        callback?.({ status: "error", message: "Kh√¥ng g·ª≠i ƒë∆∞·ª£c tin nh·∫Øn!" });
      }
    });

    // C·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng
    socket.on("orderStatusUpdate", async (data, callback) => {
      if (!data.userId)
        return callback?.({ status: "error", message: "Thi·∫øu userId!" });

      const notification = {
        title: "C·∫≠p nh·∫≠t ƒë∆°n h√†ng",
        message: `ƒê∆°n h√†ng #${data.orderId} c·∫≠p nh·∫≠t: ${data.status}`,
        data,
      };
      await sendNotificationForUser(data.userId, notification);
      if (socketUsers[data.userId])
        io.to(socketUsers[data.userId]).emit("notification", notification);
      callback?.({ status: "ok" });
    });
    // Admin th√™m b√¨nh lu·∫≠n m·ªõi
    socket.on(
      "adminComment",
      async ({ userId, postId, commentText }, callback) => {
        try {
          // L∆∞u Notification v√†o DB
          const note = new Notification({
            userId,
            title: "B√¨nh lu·∫≠n m·ªõi t·ª´ Admin",
            message: commentText,
            type: "comment",
            data: { postId },
            timestamp: new Date(),
            read: false,
          });
          await note.save();

          // G·ª≠i FCM
          await sendNotificationForUser(userId, {
            title: note.title,
            message: note.message,
            type: note.type,
            data: note.data,
          });

          // Emit socket
          if (socketUsers[userId]) {
            io.to(socketUsers[userId]).emit("newCommentNotification", note);
          }
          callback?.({ status: "ok", notification: note });
        } catch (err) {
          console.error("‚ùå L·ªói adminComment:", err);
          callback?.({ status: "error" });
        }
      }
    );

    // ·∫®n chat v·ªõi user
    socket.on("hideChatWithUser", async (userId) => {
      try {
        await HiddenUser.findOneAndUpdate(
          { adminId: "admin", userId },
          {},
          { upsert: true }
        );
        delete activeUsers[userId];
        updateAdminUserList();
      } catch (err) {
        console.log("‚ùå L·ªói khi ·∫©n user:", err);
      }
    });

    // L·∫•y danh s√°ch user ƒë√£ ·∫©n
    socket.on("getHiddenUsers", async () => {
      try {
        const hidden = await HiddenUser.find({ adminId: "admin" });
        const result = {};
        hidden.forEach((u) => (result[u.userId] = true));
        socket.emit("hiddenUsersList", result);
      } catch (err) {
        console.log("‚ùå L·ªói khi l·∫•y danh s√°ch ·∫©n:", err);
      }
    });

    // B·ªè ·∫©n user
    socket.on("unhideUser", async (userId) => {
      try {
        await HiddenUser.deleteOne({ adminId: "admin", userId });
        activeUsers[userId] = userId;
        updateAdminUserList();
      } catch (err) {
        console.log("‚ùå L·ªói khi b·ªè ·∫©n user:", err);
      }
    });

    // L·∫•y 50 tin nh·∫Øn g·∫ßn nh·∫•t
    socket.on("getMessages", async (userId) => {
      try {
        const chat = await Message.find({
          $or: [
            { sender: userId, receiver: "admin" },
            { sender: "admin", receiver: userId },
          ],
          hidden: false,
        })
          .sort({ timestamp: -1 })
          .limit(50)
          .select("sender receiver message timestamp");

        const formatted = chat.reverse().map((msg) => ({
          sender: msg.sender,
          senderName: activeUsers[msg.sender] || msg.sender,
          message: msg.message,
          timestamp: msg.timestamp,
        }));
        socket.emit("chatHistory", { userId, messages: formatted });
      } catch (err) {
        console.log("‚ùå L·ªói khi l·∫•y l·ªãch s·ª≠ tin nh·∫Øn:", err);
      }
    });

    // Disconnect
    socket.on("disconnect", () => {
      removeUser(socket);
    });
  });
};

const updateAdminUserList = async () => {
  if (!adminSocketId) return;

  if (cachedHiddenUsers.size === 0) {
    try {
      const hidden = await HiddenUser.find({ adminId: "admin" });
      cachedHiddenUsers = new Set(hidden.map((u) => u.userId));
    } catch (err) {
      console.log("‚ùå L·ªói t·∫£i danh s√°ch user ·∫©n:", err);
    }
  }

  const usersArray = Object.keys(activeUsers)
    .filter((id) => !cachedHiddenUsers.has(id))
    .map((id) => ({
      userId: id,
      username: activeUsers[id],
      lastMessageTime: messages[id]?.[messages[id].length - 1]?.timestamp || 0,
    }))
    .sort((a, b) => b.lastMessageTime - a.lastMessageTime);

  io.to(adminSocketId).emit("updateUserList", usersArray);
};
/**
 * L·∫•y danh s√°ch th√¥ng b√°o c·ªßa user (m·ªõi nh·∫•t tr∆∞·ªõc)
 */
const getUserNotifications = async (req, res) => {
  try {
    const { userId } = req.params;
    const notifications = await Notification.find({ userId })
      .sort({ createdAt: -1 })
      .limit(50); // S·ªë l∆∞·ª£ng th√¥ng b√°o t·ªëi ƒëa

    res.status(200).json({ notifications });
  } catch (err) {
    console.error("‚ùå L·ªói khi l·∫•y th√¥ng b√°o:", err);
    res.status(500).json({ message: "L·ªói server khi l·∫•y th√¥ng b√°o!" });
  }
};

/**
 * ƒê√°nh d·∫•u m·ªôt th√¥ng b√°o l√† ƒë√£ ƒë·ªçc
 */
const markAsRead = async (req, res) => {
  try {
    const { id } = req.params;
    const notification = await Notification.findByIdAndUpdate(
      id,
      { read: true },
      { new: true }
    );

    if (!notification) {
      return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y th√¥ng b√°o" });
    }

    res.status(200).json({ message: "ƒê√£ ƒë√°nh d·∫•u l√† ƒë√£ ƒë·ªçc", notification });
  } catch (err) {
    console.error("‚ùå L·ªói ƒë√°nh d·∫•u th√¥ng b√°o:", err);
    res.status(500).json({ message: "L·ªói server khi c·∫≠p nh·∫≠t th√¥ng b√°o" });
  }
};
const createNotification = async (req, res) => {
  try {
    const { userId, title, message, data } = req.body;
    const notification = new Notification({ userId, title, message, data });
    await notification.save();
    res.status(201).json(notification);
  } catch (error) {
    res.status(500).json({ message: "L·ªói khi t·∫°o th√¥ng b√°o", error });
  }
};

const removeUser = (socket) => {
  const userId = Object.keys(socketUsers).find(
    (key) => socketUsers[key] === socket.id
  );
  if (userId) {
    delete socketUsers[userId];
    delete activeUsers[userId];
    if (userId === "admin") adminSocketId = null;
    updateAdminUserList();
  }
};

module.exports = {
  initSocket,
  sendNotificationForUser,
  sendNotificationToAllUsers,
  getUserNotifications,
  markAsRead,
  createNotification,
};
